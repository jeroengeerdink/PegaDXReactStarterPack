## Implementation Related Notes

Purpose of this section is to document things of interest related to the code so that they are here for posterity to refer back to for the original developer or anyone trying to maintain this code

- React technology related

  - Why are dropdowns re-populated on every vibisble control change? Is that expected?
    - Relevant: https://www.freecodecamp.org/news/react-shouldcomponentupdate-demystified-c5d323099ef6/
      React keeps copy of old and new DOM and does a difference and only udpates differences. Lifecycle method shouldComponentUpdate might be used to have more control on which components should update when, but usage is discouraged. Would need to check if nextProps are different from current props. Something like ImmutableJS might be used to make such comparisions more efficient.
      Since DOM Diffing caussing only area of screen that has changed....it should be mostly fast enough
    - Breaking up to smaller components would help minimizing the render to only the ones impacted (yet, not sure when a container component wraps all tehse). Reducers are supposed to help this.
  - React Reducers (Redux): https://redux.js.org/tutorials/fundamentals/part-1-overview
  - React and event.preventDefault(): https://medium.com/@ericclemmons/react-event-preventdefault-78c28c950e46

- Workbaskets (or Workqueues) related

  - The list of workqueues for an operator are returned as an array within the pyWorkbasket property for the D_OperatorID data page

- Workitem related

  - The list of workitems are retrieved from either the D_Worklist data page (which supports two params: WorkGroup and OperatorID--neither of which are currently utilized) and the D_WorkBasket (which supports two params: WorkGroup and WorkBasket). We employ the WorkBasket param to specify which WorkBasket should be utilized. Login as Manager.Cableco with the sample app to exercise this.

- Casetypes related

  - We add to the New menu all the startingProcess names within any of the casetypes which have "CanCreate" set to "true". When such a "New" harness is required, the starting processID is stored within Pages state so that it can be utilized on the subsequent POST /cases transaction once the initial field values have been obtained.

- Event handler related

  - handleEvent considers the actionsets configured for a control and generates an HTTP transaction if appropriate
  - handleChange does not consider and take action on actionsets unless you pass handleEvent as a callback to this function. It does update maintained state. The DATETIME control is treated specially as the first parameter it sends back is a date (and not an event).
  - handleNamedEvent provides a way to filter on a particular event. It should be used when a control is considering events during onChange handling (via specifying handleEvent as the callback). In those cases it should use handleNamedEvent for any onBlur handling.
  - For text controls we opt to not consider fired events on every change but only on blur
  - Since it is common to have embedded section visibility change on a radio button click, checkbox, dropdown select and autocomplete select, these are wired to consider configured actionsets on change. Other controls it is preferable to do this only on blur.

- Using anonymous functions for event handlers vs. defined functions/methods.

  - Anonymous functions must be recreated every render loop. With a dedicated handler a function instance is only created once
  - Anonymous/arrow functions also allow accessing other vars in context

- Text input fields and the ENTER key

  - To properly simulate what Pega web experience does best way to eat the ENTER key for only INPUT controls is to add an onKeyPress handler to all such controls.
  - Also for the main form Buttons, the type="button" designation is important as otherwise the button click event generated by ENTER would be for the first buton rather than the type="submit" button.

- OAuth library migration from JSO to oidc-client

  - Various pages were originally created to prototype alternate login user experiences (and were originally done with the JSO library). Only the default Main has been fully converted to use the oidc-client library so far.
    - `loginBoxType.Main` correlates to replacing the entire application window contents with the OAuth provider login page (this is the default and only one "supported" within the React Starter Pack app). This variant relies on the `StartPage` component.
    - `loginBoxType.Popup` correlates to opening up a separate browser window and having the OAuth provider login UI surface there. This variant relies on the `PopupPage` component.
    - `loginBoxType.Modal` correlates to opening up inline modal dialog and displaying the OAuth provider login UI there. This gets much more complicated as enought space needs to be allocated for the display of that page within an iframe. This variant relies on the `IframePage` component. The OAuth provider's login page also needs to support being surfaced within an iframe for this variant to work. The default Pega login page does not.
  - Info on oidc-client library: https://github.com/IdentityModel/oidc-client-js/wiki

- Pega OAuth related

  - OAuth support is intended to exercise the default "OAuth 2.0" configuration for the "api" service package
  - At present (8.6) the Public client registration for "Authorization Code" doesn't provide a way to enable refresh tokens (refresh token usage is hence not currently demonstrated within this starter pack to seamlessly extend auth "sessions")
  - At present (8.6) also doesn't support ability to revoke tokens issued to Public clients.

- Routing

  - PrivateRoute.js is where the initial route is determined to /start or /login page based on whether endpoints.use_OAuth is true or false

- DROPDOWN (pxDropdown) implementation

  - "datapage" dropdowns are implemented as a custom component (DataPageDropdown). The other two variants "pageList" and "locallist" are supported by the Semantic-UI Form.Dropdown component. The code is presently treating "locallist" as an else. Perhaps it should be explicitly handled and if any other values for listSource are encountered a console log of unexpected shoud be emitted? If those were reasonable ways to specify drop down entries, would such options be located within same fields as they are now for locallist?
  - DataPage dropdowns were more complex and hence were broken out to leverage it's own custom component. If this is refactored in future to have a distinct component for every pega control type, then all might be merged into this one component.
  - When options are driven by Property with "Prompt list", then it appears only options.value might be encoded. However, when using "Local list", both these valuse may be encoded.

- AUTOCOMPLETE (pxAutoComplete) implementation

  - Unlike the current DROPDOWN implementation, all editable pxAutoComplete fields will instatiate a custom component (PegaAutoComplete). When leveraging the options values within the field's control structure, each options entry will have a key, value and (possibly) a tooltip entry. "key" is the primary displayed value within the autocomplete field and the dropdown, "value" is a description and "tooltip" is additional description.

- IMAGE (pxIcon) implementation

  - Based on iconSource property value renders different content
    - standardIcon ("Standard Icon"): Maps iconStandard property value to Semantic-UI Icon tag name value (looked up from standardIcons object defined in FormConstants.js)
    - image ("Image"): The image specified by iconImage property values can't be retrieved from pega from the DX API application context. Images might be duplicated within local assets/img directory and then dynamically loaded and displayed as a data url. Also offers code to just have this always display an image not available icon.
    - exturl ("External URL"): Renders an HTML img tag with src set to iconUrl property value
    - property ("Property"): Renders an HTML img tag with src set to iconProperty property value
    - styleclass ("Icon class"): Removes any occurrences of "pi pi-" and converts any hyhen to \_ and then attempts to display the resultant semantic ui icon equivalent

- LINK (pxLink) implementation

  - Based on iconSource property value renders different content for
    - image ("Simple Image"):
    - property ("Property"):
    - styleclass ("Icon class"):

- RADIOBUTTONS (pxRadiobuttons) implementation

  - Doesn't have code to explicitly retrieve data from non-"locallist" sources (DataPage or ClipboardPage). Rather it relies on the API to access these pages and populate the "locallist" values. For examples of how to access DataPage or ClibpardPage listsources see pxDropDown or pxAutocomplete.

- REPEATING DYNAMIC LAYOUT implementation

  - This term "Repeating Dynamic Layout" refers to when groupFormat value is "Dynamic" and layoutFormat is "REPEATINGLAYOUT"

- DATEPICKER

  - The react-datepicker seems to not generate onBlur events (see https://github.com/Hacker0x01/react-datepicker/issues/2028). On change does cause many events to be fired if typing and typing valid dates. Might try to delay the processing of these events for some small interval (1 sec) to try to avoid multiple server refresh transactions firing when a action set is hooked up to a date field.

- Understanding Pega Layouts and what is supported
  - See https://community.pega.com/knowledgebase/articles/user-experience/85/layouts-dx-api
  - layout.groupType seems to correlate to specific layouts as well as grouping used within individual visual template choices
  - The code doesn't presently inspect layout.formatType values of SCREENLAYOUT, SIMPLELAYOUT (Dynamic layout), REPEATINGROW (Repeating Dynamic Layouts), or TABLELAYOUT (Grid), but rather supports these by coping with other layout properties such as layout.groupType
